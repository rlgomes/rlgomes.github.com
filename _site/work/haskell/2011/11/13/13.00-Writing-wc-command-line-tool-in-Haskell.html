<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Writing wc command line tool in Haskell</title>
        <meta name="description" content="Rodney's Blog">
        <meta name="author" content="Rodney Gomes">

        <link rel="alternate"
              type="application/rss+xml"
              title="Rodney's Corner RSS Feed"
              href="http://feeds.feedburner.com/rlgomesgithubcom/feed"/>

        <link href="/css/bootstrap.css" rel="stylesheet">
        <link href="/css/main.css" rel="stylesheet"/>
    </head>
    <body>

    <div class="topbar">
      <div class="fill">
        <div class="container">
          <a class="brand" href="/">Rodney's Corner</a>
          <ul class="nav">
            <li class="active"><a href="/">Blog</a></li>
            <li><a href="/archive.html">Archive</a></li>
            <li><a href="/about.html">About</a></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="content">
        <div class="page-header">
          <h1>Writing wc command line tool in Haskell</h1>
        </div>
        <div class="row">
          <div class="span10">
             <article>
                   <div id="post.body"><p>Now after having gotten a pretty good overview of how to use Haskell&#8217;s most important features we can now use this newly learned skills to write a clone of the &#8216;wc&#8217; command line tool completely in Haskell and compare this to what the current code for the wc command line tool is written in.</p>

<p>The &#8216;wc&#8217; command has the following help menu on my linux box:</p>
<console>
$ wc --help
Usage: wc [OPTION]... [FILE]...
  or:  wc [OPTION]... --files0-from=F
Print newline, word, and byte counts for each FILE, and a total line if
more than one FILE is specified.  With no FILE, or when FILE is -,
read standard input.  A word is a non-zero-length sequence of characters
delimited by white space.
  -c, --bytes            print the byte counts
  -m, --chars            print the character counts
  -l, --lines            print the newline counts
      --files0-from=F    read input from the files specified by
                           NUL-terminated names in file F;
                           If F is - then read names from standard input
  -L, --max-line-length  print the length of the longest line
  -w, --words            print the word counts
      --help     display this help and exit
      --version  output version information and exit

Report wc bugs to bug-coreutils@gnu.org
GNU coreutils home page: http://www.gnu.org/software/coreutils/
General help using GNU software: http://www.gnu.org/gethelp/
For complete documentation, run: info coreutils 'wc invocation'
</console>
<p>So we&#8217;re going to try and implement the counting of characters, lines and words and also make sure that we can handle piping of a file to the stdin with our newly created command line tool.</p>

<p>First thing that is required to write a command line tool is a command line parsing library. I choose CmdArgs since I found it worked really well and allowed you to easily define the help menu and and summary quite nicely. You can read up on this library <a href='http://community.haskell.org/~ndm/cmdargs/'>here</a>.</p>

<p>The <strong>CmdArgs</strong> library is really great at expressing what arguments are available and what each of them do. You have to firstly define the datatype that identifies the various arguments and their types, like so:</p>
<div class='highlight'><pre><code class='hs'><span class='kr'>data</span> <span class='kt'>WC</span> <span class='ow'>=</span> <span class='kt'>WC</span> <span class='p'>{</span><span class='n'>chars</span> <span class='ow'>::</span> <span class='kt'>Bool</span><span class='p'>,</span> <span class='n'>lines_</span> <span class='ow'>::</span> <span class='kt'>Bool</span><span class='p'>,</span> <span class='n'>words_</span> <span class='ow'>::</span> <span class='kt'>Bool</span><span class='p'>}</span>
    <span class='kr'>deriving</span> <span class='p'>(</span><span class='kt'>Show</span><span class='p'>,</span> <span class='kt'>Data</span><span class='p'>,</span> <span class='kt'>Typeable</span><span class='p'>)</span><span class='o'>$</span>
</code></pre>
</div>
<p>So the above just defines that we have 3 flags that can be used and each of them are either present or not (ie Bool type). The underscore following the name is used whenever you have a namespace collision such as the fact that <strong>lines</strong> and <strong>words</strong> are both functions that already existing in <strong>Haskell</strong>. CmdArgs will automatically strip the underscore when parsing the command line.</p>

<p>We now have to instantiate our WC data type and fill in the required information on what each option does as well as give some additional information on what the tool does and how to use it. Here is how this is done in <strong>Haskell</strong> when using <strong>CmdArgs</strong>:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>wc</span> <span class='ow'>=</span> <span class='kt'>WC</span> <span class='p'>{</span> <span class='n'>chars</span> <span class='ow'>=</span> <span class='n'>def</span> <span class='o'>&amp;=</span> <span class='n'>name</span> <span class='s'>&quot;m&quot;</span> <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='s'>&quot;print the byte counts&quot;</span><span class='p'>,</span>
          <span class='n'>lines_</span> <span class='ow'>=</span> <span class='n'>def</span> <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='s'>&quot;print the character counts&quot;</span><span class='p'>,</span>
          <span class='n'>words_</span> <span class='ow'>=</span> <span class='n'>def</span> <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='s'>&quot;print the word counts&quot;</span> <span class='p'>}</span>
        <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='p'>(</span><span class='s'>&quot;Print newline, word, and byte counts for each FILE, &quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot;and a total line if more than one FILE is specified.&quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot; With no FILE, or when FILE is -, read standard &quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot;input.  A word is a non-zero-length sequence of &quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot;characters delimited by white space.&quot;</span><span class='p'>)</span>
        <span class='o'>&amp;=</span> <span class='n'>summary</span> <span class='s'>&quot;wc v0.0.1, (C) Rodney Gomes&quot;</span>
</code></pre>
</div>
<p>The above is using the <strong>&amp;=</strong> operator is used to annotation the chars type with additional information such as the name of the option and the help to show when displaying this option. The whole <strong>WC</strong> datatype is annotated with the <strong>help</strong> and <strong>summary</strong> which are then used to generate the help menu like so:</p>
<console>
wc v0.0.1, (C) Rodney Gomes

wc [OPTIONS]
  Print newline, word, and byte counts for each FILE, and a total line if more
  than one FILE is specified. With no FILE, or when FILE is -, read standard
  input.  A word is a non-zero-length sequence of characters delimited by white
  space.

Common flags:
  -m --chars    print the byte counts
  -l --lines    print the character counts
  -w --words    print the word counts
  -? --help     Display help message
  -V --version  Print version information
</console>
<p>There you have your argument parsing and menu printing all in less than 15 lines of <strong>Haskell</strong>. The next bit we&#8217;re going to focus on is how do we actually count lines, words and characters using <strong>Haskell</strong>. Instead of writing functions that can calculate the number of lines/words in a <strong>String</strong> we can easily look through the <strong>Prelude</strong> module and find that there are two functions that do the trick: <strong>lines</strong> and <strong>words</strong> and using the already familiar function composition we can write:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>countlines</span> <span class='ow'>=</span> <span class='n'>length</span> <span class='o'>.</span> <span class='n'>lines</span>
<span class='nf'>countwords</span> <span class='ow'>=</span> <span class='n'>length</span> <span class='o'>.</span> <span class='n'>words</span>
</code></pre>
</div>
<p>Now creating a main function in Haskell requires you understand a few things about the way <strong>IO</strong> is handled. In <strong>Haskell</strong> as mentioned early in my posts is a purely functional language and for things such as <strong>IO</strong> which are basically side effects within your function <strong>Haskell</strong>. This side-effect is handled by expressing side effects as a <strong>Monad</strong>. Now I won&#8217;t go into all of the details of a <strong>Monad</strong> in this post and I suggest you read up on Monads with these few links:</p>

<ul>
<li>
<p><a href='http://mvanier.livejournal.com/3917.html'>Yet Another Monad Tutorial</a> is a great source of informatoin but its very detailed and runs over the course of a few posts</p>
</li>

<li>
<p><a href='http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf'>Monads for functional programming</a> the original <strong>Monad</strong> paper that expresses how to use <strong>Monads</strong> within a functional language so you can do impure actions within a pure function.</p>
</li>
</ul>

<p>The quick and dirty introduction to <strong>Monads</strong> is tha they&#8217;re used to do a few things that we take for granted in other imperative languages, such as: exceptions, state, output. In the case of the <strong>main</strong> function has an <strong>IO ()</strong> which just means that this function generates output and returns the unit type <strong>()</strong> which I usually view as <strong>void</strong> in Haskell. Lets look at a simple program that prints &#8216;Hello World&#8217;:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>main</span> <span class='ow'>=</span> <span class='n'>putStrLn</span> <span class='s'>&quot;Hello World&quot;</span>
</code></pre>
</div>
<p>The function <strong>putStrLn</strong> of course has a type of</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>putStrLn</span> <span class='ow'>::</span> <span class='kt'>String</span> <span class='ow'>-&gt;</span> <span class='kt'>IO</span> <span class='nb'>()</span>
</code></pre>
</div>
<p>The other thing to introduce is the <strong>do</strong> notation which is heavily used along side <strong>Monads</strong> because it better expresses the imperative sense of the Monadic actions. Its not the only way to express monadic actions but seems to be the easiest to start with for developers coming from the imperative world. I would read up on the other available options when trying to chain monadic actions becuase you&#8217;ll find that <strong>Haskell</strong> has very elegant ways of handling this. The notation itself allows you to execute separate statements that are not necessarily used when generating the output of your function. For example:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>main</span> <span class='ow'>=</span> <span class='kr'>do</span>
         <span class='n'>putStrLn</span> <span class='s'>&quot;Input name:&quot;</span>
         <span class='n'>name</span> <span class='ow'>&lt;-</span> <span class='n'>getLine</span>
         <span class='n'>putStrLn</span> <span class='p'>(</span><span class='s'>&quot;Hi there &quot;</span> <span class='o'>++</span> <span class='n'>name</span><span class='p'>)</span>
</code></pre>
</div>
<p>There you can see some Haskell code that looks extremely like an imperative program. Now you don&#8217;t have to write things like that and can in fact be more functional when writing code in <strong>Haskell</strong> and do the same like so:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>main</span> <span class='ow'>=</span> <span class='n'>putStrLn</span> <span class='s'>&quot;Input name:&quot;</span> <span class='o'>&gt;&gt;</span> <span class='n'>getLine</span> <span class='o'>&gt;&gt;=</span> <span class='n'>putStrLn</span> <span class='o'>.</span> <span class='p'>(</span><span class='o'>++</span><span class='p'>)</span> <span class='s'>&quot;Hello there &quot;</span>
</code></pre>
</div>
<p>There are a few new functions being used here which you may already know if read the tutorials on <strong>Monads</strong> I previously mentioned but they&#8217;re not hard to understand the first is <strong>&#187;</strong> which has the signature:</p>
<div class='highlight'><pre><code class='hs'><span class='p'>(</span><span class='o'>&gt;&gt;</span><span class='p'>)</span> <span class='ow'>::</span> <span class='p'>(</span><span class='kt'>Monad</span> <span class='n'>m</span><span class='p'>)</span> <span class='ow'>=&gt;</span> <span class='n'>m</span> <span class='n'>a</span> <span class='ow'>-&gt;</span> <span class='n'>m</span> <span class='n'>b</span> <span class='ow'>-&gt;</span> <span class='n'>m</span> <span class='n'>b</span>
</code></pre>
</div>
<p>What it does is simply accept two monadic actoins and only return the second, basically ignore the return from the first function. This was necessary since we wanted to print the &#8220;Input name:&#8221; string but didn&#8217;t care for its return. The <strong>&#187;=</strong> function on the other hand is the function composition function for Monadic functions. Its signature is more familiar:</p>
<div class='highlight'><pre><code class='hs'><span class='p'>(</span><span class='o'>&gt;&gt;=</span><span class='p'>)</span> <span class='ow'>::</span> <span class='p'>(</span><span class='kt'>Monad</span> <span class='n'>m</span><span class='p'>)</span> <span class='ow'>=&gt;</span> <span class='n'>m</span> <span class='n'>a</span> <span class='ow'>-&gt;</span> <span class='p'>(</span><span class='n'>a</span> <span class='ow'>-&gt;</span> <span class='n'>m</span> <span class='n'>b</span><span class='p'>)</span> <span class='ow'>-&gt;</span> <span class='n'>m</span> <span class='n'>b</span>
</code></pre>
</div>
<p>You can easily see what the function does and its purpose with in <strong>Haskell</strong>. Then the only other magic done in that one line was to infix the <strong>++</strong> operator and use it to concatenate the return of the <strong>getLine</strong> with the &#8220;Hello there &#8221; string. I really prefer not using the <strong>do</strong> notation when possible just because its not as functionally elegant as other available options. I think its a matter of taste and you&#8217;ll find what makes more sense to use in different situations.</p>

<p>So the only thing missing is the ability to handle the input from the standard input from our program in our program. In the <strong>Prelude</strong> there is a function that allows us to handle the stdin and output directly to the stdout. This is the <strong>interact</strong> function:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>interact</span> <span class='ow'>::</span> <span class='p'>(</span><span class='kt'>String</span> <span class='ow'>-&gt;</span> <span class='kt'>String</span><span class='p'>)</span> <span class='ow'>-&gt;</span> <span class='kt'>IO</span> <span class='nb'>()</span>
</code></pre>
</div>
<p>This function will take your <strong>String-&gt;String</strong> function and do the required <strong>IO ()</strong> output. The input to your function is the whole of the standard input and what you&#8217;ll be returning is the whole of what you want to be printed on the screen (ie standard output). So you can basically apply the <strong>countlines</strong> function like so:</p>
<div class='highlight'><pre><code class='hs'><span class='kr'>module</span> <span class='nn'>Main</span> <span class='p'>(</span><span class='nf'>main</span><span class='p'>)</span> <span class='kr'>where</span>

<span class='nf'>countlines</span> <span class='ow'>=</span> <span class='n'>show</span> <span class='o'>.</span> <span class='n'>length</span> <span class='o'>.</span> <span class='n'>lines</span>
<span class='nf'>main</span> <span class='ow'>=</span> <span class='n'>interact</span> <span class='n'>countlines</span>
</code></pre>
</div>
<p>I just introduced the module declaration line to also show how to correctly define your module and tell the ghci compilere which function is your main entry point. We had to use the <strong>show</strong> function to convert the number calculated by our countlines function back into a <strong>String</strong>. With the above you should be able to run commands such as:</p>
<console>
$ cat test.hs | runhaskell test.hs
5
</console>
<p>With all that we&#8217;ve gone over at this point you should be able to write up the <strong>wc</strong> command line tool and it may look something like this:</p>
<div class='highlight'><pre><code class='hs'><span class='o'>#!</span> <span class='o'>/</span><span class='n'>usr</span><span class='o'>/</span><span class='n'>bin</span><span class='o'>/</span><span class='n'>env</span> <span class='n'>runhaskell</span>
<span class='cm'>{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class='kr'>module</span> <span class='nn'>Main</span> <span class='p'>(</span><span class='nf'>main</span><span class='p'>)</span> <span class='kr'>where</span>

<span class='kr'>import</span> <span class='nn'>System.Console.CmdArgs</span>
<span class='kr'>import</span> <span class='nn'>Control.Arrow</span>

<span class='kr'>data</span> <span class='kt'>WC</span> <span class='ow'>=</span> <span class='kt'>WC</span> <span class='p'>{</span><span class='n'>chars</span> <span class='ow'>::</span> <span class='kt'>Bool</span><span class='p'>,</span> <span class='n'>lines_</span> <span class='ow'>::</span> <span class='kt'>Bool</span><span class='p'>,</span> <span class='n'>words_</span> <span class='ow'>::</span> <span class='kt'>Bool</span><span class='p'>}</span>
    <span class='kr'>deriving</span> <span class='p'>(</span><span class='kt'>Show</span><span class='p'>,</span> <span class='kt'>Data</span><span class='p'>,</span> <span class='kt'>Typeable</span><span class='p'>)</span>

<span class='nf'>wc</span> <span class='ow'>=</span> <span class='kt'>WC</span> <span class='p'>{</span> <span class='n'>chars</span> <span class='ow'>=</span> <span class='n'>def</span> <span class='o'>&amp;=</span> <span class='n'>name</span> <span class='s'>&quot;m&quot;</span> <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='s'>&quot;print the byte counts&quot;</span><span class='p'>,</span>
          <span class='n'>lines_</span> <span class='ow'>=</span> <span class='n'>def</span> <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='s'>&quot;print the character counts&quot;</span><span class='p'>,</span>
          <span class='n'>words_</span> <span class='ow'>=</span> <span class='n'>def</span> <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='s'>&quot;print the word counts&quot;</span> <span class='p'>}</span>
        <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='p'>(</span><span class='s'>&quot;Print newline, word, and byte counts for each FILE, &quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot;and a total line if more than one FILE is specified.&quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot; With no FILE, or when FILE is -, read standard &quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot;input.  A word is a non-zero-length sequence of &quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot;characters delimited by white space.&quot;</span><span class='p'>)</span>
        <span class='o'>&amp;=</span> <span class='n'>summary</span> <span class='s'>&quot;wc v0.0.1, (C) Rodney Gomes&quot;</span>

<span class='nf'>countwords</span> <span class='ow'>=</span> <span class='n'>show</span> <span class='o'>.</span> <span class='n'>length</span> <span class='o'>.</span> <span class='n'>words</span>
<span class='nf'>countlines</span> <span class='ow'>=</span> <span class='n'>show</span> <span class='o'>.</span> <span class='n'>length</span> <span class='o'>.</span> <span class='n'>lines</span>
<span class='nf'>countchars</span> <span class='ow'>=</span> <span class='n'>show</span> <span class='o'>.</span> <span class='n'>length</span>

<span class='nf'>flat</span> <span class='p'>(</span><span class='n'>a</span><span class='p'>,(</span><span class='n'>b</span><span class='p'>,</span><span class='n'>c</span><span class='p'>))</span> <span class='ow'>=</span> <span class='s'>&quot; &quot;</span> <span class='o'>++</span> <span class='n'>a</span> <span class='o'>++</span> <span class='s'>&quot; &quot;</span> <span class='o'>++</span>  <span class='n'>b</span> <span class='o'>++</span> <span class='s'>&quot; &quot;</span> <span class='o'>++</span> <span class='n'>c</span>

<span class='nf'>optionHandler</span> <span class='kt'>WC</span><span class='p'>{</span><span class='n'>chars</span><span class='ow'>=</span><span class='kt'>True</span><span class='p'>}</span> <span class='ow'>=</span> <span class='n'>countchars</span>
<span class='nf'>optionHandler</span> <span class='kt'>WC</span><span class='p'>{</span><span class='n'>lines_</span><span class='ow'>=</span><span class='kt'>True</span><span class='p'>}</span> <span class='ow'>=</span> <span class='n'>countlines</span>
<span class='nf'>optionHandler</span> <span class='kt'>WC</span><span class='p'>{</span><span class='n'>words_</span><span class='ow'>=</span><span class='kt'>True</span><span class='p'>}</span> <span class='ow'>=</span> <span class='n'>countwords</span>
<span class='nf'>optionHandler</span> <span class='kr'>_</span> <span class='ow'>=</span> <span class='n'>flat</span> <span class='o'>.</span> <span class='p'>(</span> <span class='n'>countlines</span> <span class='o'>&amp;&amp;&amp;</span> <span class='n'>countwords</span> <span class='o'>&amp;&amp;&amp;</span> <span class='n'>countchars</span> <span class='p'>)</span>

<span class='nf'>main</span> <span class='ow'>=</span> <span class='n'>cmdArgs</span> <span class='n'>wc</span> <span class='o'>&gt;&gt;=</span> <span class='n'>interact</span> <span class='o'>.</span> <span class='n'>optionHandler</span>
</code></pre>
</div>
<p>That is a our implementation of the <strong>wc</strong> command line tool (minus the counting of bytes and some of the extended options). There are a few more things introduced in this implementation tht weren&#8217;t covered before such as:</p>

<ul>
<li>
<p><strong>&amp;&amp;&amp;</strong> operator, also called the &#8216;fanout&#8217; operator which has the following signature <strong><em>(&amp;&amp;&amp;) :: a b c -&gt; a b c&#8217; -&gt; a b (c, c&#8217;)</em></strong> is basically used to apply the two functions to the same arguemnt and return the result which consists of the tuples of the results of those two functions. We then created a <strong>flat</strong> function to flatten out the result of applying using the <strong>&amp;&amp;&amp;</strong> operator.</p>
</li>

<li>
<p><strong>records pattern matching</strong> - we had introduced the records notation which allows you to basically allows you to define the chars,lines_ and words_ functions which can be used against the <strong>WC</strong> datatype. Now when pattern matching you can use the same function to match the exact element you&#8217;re looking for and thats what we&#8217;ve done above in the <strong>optionHandler</strong> function.</p>
</li>
</ul>

<p>The most astounding thing about the above piece of code is how many lines we&#8217;ve actually had to write. The above code is exactly 34 lines of code (in its current incarnation) and the source for the current C implementation of the <strong>wc</strong> command line tool in the source of my current <strong>Ubuntu Oneiric</strong> installation is over 700 lines of code.</p>

<p>Of course lines of code is not a true way to compare software quality between different languages, but it is a measure of complexity. The biggest difference here is how easy it is to read this code vs reading the same program written in C. Just looking at the code above you can see how easy it is to add more functionality and also how easy it is to read the program.</p>

<p>In the next post we&#8217;re going to actualy analyze the performance of the <strong>wc</strong> command we wrote and see how close we can get to the performance of the C implementation of the wc command.</p></div>
             </article>
             <hr/>
             <div id="disqus_thread"></div>
             <script type="text/javascript">
                    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                    var disqus_shortname = 'rodneyscorner'; // required: replace example with your forum shortname

                    /* * * DON'T EDIT BELOW THIS LINE * * */
                    (function() {
                        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                    })();
              </script>
              <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
          <div class="span4">
            
                <h2>Related Posts</h2>
                <ul>
                    
                    <li><a href="/work/haskell/2011/11/14/20.30-Optimizing-Haskell-Programs.html">Optimizing Haskell Programs</a></li>
                    
                    <li><a href="/work/haskell/2011/11/08/22.30-Advanced-Typeclasses.html">Advanced Typeclasses</a></li>
                    
                    <li><a href="/work/haskell/2011/11/01/23.00-Higher-order-functions-in-Haskell.html">Higher order functions in Haskell</a></li>
                    
                    <li><a href="/work/haskell/2011/10/31/20.00-Custom-data-types-in-Haskell.html">Custom data types in Haskell</a></li>
                    
                    <li><a href="/work/haskell/2011/10/30/20.00-haskell-basics.html">Haskell Basics</a></li>
                    
                </ul>
            
          </div>
        </div>
      </div>
      <footer>
        <div style="text-align: right">Powered by <a href="http://jekyllrb.com/">Jekyll</a> &amp; <a href="http://twitter.github.com/bootstrap/index.html">Bootstrap</a></div>
        <div style="text-align: right">Last Updated: Wed May 16 16:16:15 -0700 2012</div>
      </footer>
    </div> <!-- /container -->
</html>
