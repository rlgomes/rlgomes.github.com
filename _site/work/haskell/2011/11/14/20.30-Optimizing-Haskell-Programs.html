<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Optimizing Haskell Programs</title>
        <meta name="description" content="Rodney's Blog">
        <meta name="author" content="Rodney Gomes">

        <link rel="alternate"
              type="application/rss+xml"
              title="Rodney's Corner RSS Feed"
              href="http://feeds.feedburner.com/rlgomesgithubcom/feed"/>

        <link href="/css/bootstrap.css" rel="stylesheet">
        <link href="/css/main.css" rel="stylesheet"/>
    </head>
    <body>

    <div class="topbar">
      <div class="fill">
        <div class="container">
          <a class="brand" href="/">Rodney's Corner</a>
          <ul class="nav">
            <li class="active"><a href="/">Blog</a></li>
            <li><a href="/archive.html">Archive</a></li>
            <li><a href="/about.html">About</a></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="content">
        <div class="page-header">
          <h1>Optimizing Haskell Programs</h1>
        </div>
        <div class="row">
          <div class="span10">
             <article>
                   <div id="post.body"><p>Before we start optimizing the <strong>wc</strong> command line tool we wrote lets first find a simple way to compare this implementation with the wc command tool available on my linux (written in C). I created a file with 197,000 dummy lines (with each line just over 80 characters long) and measured how long it takes to count the number of lines, with each tool:</p>
<console>
time bash -c "cat test | wc -l"
197000
bash -c "cat test | wc -l"  0.00s user 0.02s system 65% cpu 0.043 total

time bash -c "cat test | ./wc.hs -l"
197000
bash -c "cat test | ./wc.hs -l"  1.46s user 0.07s system 95% cpu 1.590 total
</console>
<p>So the current <strong>Haskell</strong> implementation is 37x slower than the native C version. The first thing to note is how running the haskell program without compiling is not efficient at all. So lets put together a simple make file and use <strong>ghci</strong> to compile the <strong>.hs</strong> file to a native executable. Here&#8217;s a possible make file:</p>
<div class='highlight'><pre><code class='makefile'><span class='nf'>init</span><span class='o'>:</span>
    mkdir -p build
    cp *.hs build

<span class='nf'>wc</span><span class='o'>:</span> <span class='m'>wc.hs init</span>
    <span class='nb'>cd </span>build ; ghc --make wc.hs -o wc

<span class='nf'>clean</span><span class='o'>:</span>
    rm -fr build *.o *.hi
</code></pre>
</div>
<p>So after a simple compilation the results we&#8217;re now getting are:</p>
<console>
time bash -c "cat test | build/wc -l"
197000
bash -c "cat test | build/wc -l"  0.96s user 0.04s system 95% cpu 1.049 total
</console>
<p>Which puts at at 24x slower which is already some progress with absolutely no code changes. Now the <strong>ghc</strong> compiler also allows you to use a few optimizing flags that can help make the output code quicker. Lets use the basie <strong>-O2</strong> optimization and see how much we can gain. We&#8217;ll actually add the compilation directive to the <strong>.hs</strong> file with the following line:</p>
<div class='highlight'><pre><code class='hs'><span class='o'>#!</span> <span class='o'>/</span><span class='n'>usr</span><span class='o'>/</span><span class='n'>bin</span><span class='o'>/</span><span class='n'>env</span> <span class='n'>runhaskell</span>
<span class='cm'>{-# LANGUAGE DeriveDataTypeable #-}</span>
<span class='cm'>{-# OPTIONS_GHC -O2 #-}</span>
<span class='o'>...</span><span class='n'>_removed</span> <span class='n'>other</span> <span class='n'>code</span> <span class='n'>from</span> <span class='n'>here</span>
</code></pre>
</div>
<p>Now after recompiling, here is the current performance of our tool:</p>
<console>
time bash -c "cat test | build/wc -l"
197000
bash -c "cat test | build/wc -l"  0.96s user 0.04s system 95% cpu 1.049 total
</console>
<p>Not much of a boost really and its not a surprise since our program isn&#8217;t very complicated we can&#8217;t expect the compiler to be able to save time that easily. There are a few things to look at before we start profiling and here&#8217;s a list of the usual suspects when it comes to bad performance in <strong>Haskell</strong>:</p>

<ol>
<li>
<p><strong>String</strong> is painfully slow and is known for being 20x slower than a similar C implementation. The fix is to use the <strong>ByteString</strong> type which is known to only be 2x slower than a similar C implementation.</p>
</li>

<li>
<p>read and show are known to also perform badly and you should use the same functions that manipulate the <strong>ByteString</strong> datatype.</p>
</li>
</ol>

<p>So lets start by importing the required library to use the <strong>ByteString</strong> datatype and using all of the functions that handle <strong>ByteString</strong>. Be aware that it can be a bit of hassle to get your functions working with the <strong>ByteString</strong> data type and quite a bit of work to get all the types lined up just write, but here&#8217;s what the <strong>wc</strong> command implementation looks like that now uses <strong>ByteString</strong>s:</p>
<div class='highlight'><pre><code class='hs'><span class='o'>#!</span> <span class='o'>/</span><span class='n'>usr</span><span class='o'>/</span><span class='n'>bin</span><span class='o'>/</span><span class='n'>env</span> <span class='n'>runhaskell</span>
<span class='cm'>{-# LANGUAGE DeriveDataTypeable #-}</span>
<span class='cm'>{-# OPTIONS_GHC -O2 #-}</span>

<span class='kr'>module</span> <span class='nn'>Main</span> <span class='p'>(</span><span class='nf'>main</span><span class='p'>)</span> <span class='kr'>where</span>

<span class='kr'>import</span> <span class='nn'>System....</span>
<span class='kr'>import</span> <span class='nn'>Control.Arrow</span>
<span class='kr'>import</span> <span class='k'>qualified</span> <span class='nn'>Data.ByteString.Char8</span> <span class='k'>as</span> <span class='n'>C</span>

<span class='kr'>data</span> <span class='kt'>WC</span> <span class='ow'>=</span> <span class='kt'>WC</span> <span class='p'>{</span><span class='n'>chars</span> <span class='ow'>::</span> <span class='kt'>Bool</span><span class='p'>,</span> <span class='n'>lines_</span> <span class='ow'>::</span> <span class='kt'>Bool</span><span class='p'>,</span> <span class='n'>words_</span> <span class='ow'>::</span> <span class='kt'>Bool</span><span class='p'>}</span>
    <span class='kr'>deriving</span> <span class='p'>(</span><span class='kt'>Show</span><span class='p'>,</span> <span class='kt'>Data</span><span class='p'>,</span> <span class='kt'>Typeable</span><span class='p'>)</span>

<span class='nf'>wc</span> <span class='ow'>=</span> <span class='kt'>WC</span> <span class='p'>{</span> <span class='n'>chars</span> <span class='ow'>=</span> <span class='n'>def</span> <span class='o'>&amp;=</span> <span class='n'>name</span> <span class='s'>&quot;m&quot;</span> <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='s'>&quot;print the byte counts&quot;</span><span class='p'>,</span>
          <span class='n'>lines_</span> <span class='ow'>=</span> <span class='n'>def</span> <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='s'>&quot;print the character counts&quot;</span><span class='p'>,</span>
          <span class='n'>words_</span> <span class='ow'>=</span> <span class='n'>def</span> <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='s'>&quot;print the word counts&quot;</span> <span class='p'>}</span>
        <span class='o'>&amp;=</span> <span class='n'>help</span> <span class='p'>(</span><span class='s'>&quot;Print newline, word, and byte counts for each FILE, &quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot;and a total line if more than one FILE is specified.&quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot; With no FILE, or when FILE is -, read standard &quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot;input.  A word is a non-zero-length sequence of &quot;</span> <span class='o'>++</span>
                 <span class='s'>&quot;characters delimited by white space.&quot;</span><span class='p'>)</span>
        <span class='o'>&amp;=</span> <span class='n'>summary</span> <span class='s'>&quot;wc v0.0.1, (C) Rodney Gomes&quot;</span>

<span class='nf'>countwords</span> <span class='ow'>=</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>pack</span> <span class='o'>.</span> <span class='n'>show</span> <span class='o'>.</span> <span class='n'>length</span> <span class='o'>.</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>words</span>
<span class='nf'>countlines</span> <span class='ow'>=</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>pack</span> <span class='o'>.</span> <span class='n'>show</span> <span class='o'>.</span> <span class='n'>length</span> <span class='o'>.</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>lines</span>
<span class='nf'>countchars</span> <span class='ow'>=</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>pack</span> <span class='o'>.</span> <span class='n'>show</span> <span class='o'>.</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>length</span>

<span class='nf'>space</span> <span class='ow'>=</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>pack</span> <span class='s'>&quot; &quot;</span>
<span class='nf'>flat</span> <span class='p'>(</span><span class='n'>a</span><span class='p'>,(</span><span class='n'>b</span><span class='p'>,</span><span class='n'>c</span><span class='p'>))</span> <span class='ow'>=</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>concat</span><span class='p'>(</span> <span class='n'>a</span> <span class='kt'>:</span> <span class='n'>space</span> <span class='kt'>:</span> <span class='n'>b</span> <span class='kt'>:</span> <span class='n'>space</span> <span class='kt'>:</span> <span class='n'>c</span> <span class='kt'>:</span> <span class='kt'>[]</span> <span class='p'>)</span>

<span class='nf'>addnl</span> <span class='n'>x</span> <span class='ow'>=</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>concat</span><span class='p'>(</span> <span class='n'>x</span> <span class='kt'>:</span> <span class='p'>(</span><span class='kt'>C</span><span class='o'>.</span><span class='n'>pack</span> <span class='s'>&quot;</span><span class='se'>\n</span><span class='s'>&quot;</span><span class='p'>)</span> <span class='kt'>:</span> <span class='kt'>[]</span><span class='p'>)</span>
<span class='nf'>optionHandler</span> <span class='kt'>WC</span><span class='p'>{</span><span class='n'>chars</span><span class='ow'>=</span><span class='kt'>True</span><span class='p'>}</span> <span class='ow'>=</span> <span class='n'>addnl</span> <span class='o'>.</span> <span class='n'>countchars</span>
<span class='nf'>optionHandler</span> <span class='kt'>WC</span><span class='p'>{</span><span class='n'>lines_</span><span class='ow'>=</span><span class='kt'>True</span><span class='p'>}</span> <span class='ow'>=</span> <span class='n'>addnl</span> <span class='o'>.</span> <span class='n'>countlines</span>
<span class='nf'>optionHandler</span> <span class='kt'>WC</span><span class='p'>{</span><span class='n'>words_</span><span class='ow'>=</span><span class='kt'>True</span><span class='p'>}</span> <span class='ow'>=</span> <span class='n'>addnl</span> <span class='o'>.</span> <span class='n'>countwords</span>
<span class='nf'>optionHandler</span> <span class='kr'>_</span> <span class='ow'>=</span> <span class='n'>addnl</span> <span class='o'>.</span> <span class='n'>flat</span> <span class='o'>.</span> <span class='p'>(</span> <span class='n'>countlines</span> <span class='o'>&amp;&amp;&amp;</span> <span class='n'>countwords</span> <span class='o'>&amp;&amp;&amp;</span> <span class='n'>countchars</span> <span class='p'>)</span>

<span class='nf'>main</span> <span class='ow'>=</span> <span class='n'>cmdArgs</span> <span class='n'>wc</span> <span class='o'>&gt;&gt;=</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>interact</span> <span class='o'>.</span> <span class='n'>optionHandler</span>
</code></pre>
</div>
<p>Just a few tweaks really in terms of the functions being used and how to handle the new <strong>ByteString</strong> datatype. I also realized that the tool wasn&#8217;t outputting a necessary newline at the end of the output so I added that. After this small change surprisingly enough we&#8217;re now really close to the C implementation speed:</p>
<console>
time bash -c "cat test | build/wc -l"
197000
bash -c "cat test | build/wc -l"  0.02s user 0.04s system 77% cpu 0.073 total
</console>
<p>Now we&#8217;re still 69% slower than the C implementation which means we have room for improvmenet, but the interesting part is we&#8217;re actually 72% faster than the C implementation when we have to calculate the numbe of lines, words and characters at the same time:</p>
<console>
time bash -c "cat test | wc"
 197000 3743000 19306000
bash -c "cat test | wc"  0.57s user 0.02s system 95% cpu 0.613 total

time bash -c "cat test | build/wc"
197000 3743000 19306000
bash -c "cat test | build/wc"  0.30s user 0.04s system 94% cpu 0.357 total
</console>
<p>Now we&#8217;ve reached the point where if we want to get our counting of lines to perform as well as the C implementation we&#8217;re going to have to profile our <strong>Haskell</strong> program. To profile we need to compile with a few additional flags:</p>
<div class='highlight'><pre><code class='makefile'><span class='nf'>wc</span><span class='o'>:</span> <span class='m'>wc.hs init</span>
    <span class='nb'>cd </span>build ; ghc -prof -auto-all -rtsopts --make wc.hs -o wc
</code></pre>
</div>
<p>We added the <strong>-prof -auto-all</strong> to build with profiling enabled, the -auto-all generates cost centres for all top level functions, you can read more about that in the <strong>Haskell</strong> documentation on profiling. When you try to run the <strong>make wc</strong> again if you get something like so:</p>
<console>
wc.hs:7:8:
    Could not find module `System....':
      Perhaps you haven't installed the profiling libraries for package
                                                                  `cmdargs-0.9'?
      Use -v to see a list of the files searched for.
</console>
<p>Just run the cabal install command like so for each package:</p>
<console>
cabal install --reinstall -p cmdargs
</console>
<p>That will reinstall the package and make sure to compile the required profiling information. You can now run the same command like so:</p>
<console>
wc -l +RTS -p -RTS
</console>
<p>You&#8217;l now have a nice <strong>wc.prof</strong> file to look at which contains information like this in it (slightly reformatted to fit):</p>
<console>
    Mon Nov 14 19:05 2011 Time and Allocation Profiling Report  (Final)

       wc +RTS -p -RTS -l

    total time  =        0.04 secs   (2 ticks @ 20 ms)
    total alloc =  13,593,584 bytes  (excludes profiling overheads)

COST CENTRE                    MODULE               %time %alloc
main                           Main                  50.0    1.3
countlines                     Main                  50.0   98.5

                                                    individual    inherited
COST CENTRE              MODULE            no. entries %time %alloc %time %alloc

MAIN            MAIN                         1   0    0.0    0.0   100.0   100.0
 main           Main                       358   3   50.0    1.3   100.0    99.9
  optionHandler Main                       361   1    0.0    0.0    50.0    98.5
   addnl        Main                       363   1    0.0    0.0     0.0     0.0
   countlines   Main                       362   2   50.0   98.5    50.0    98.5
  wc            Main                       360   0    0.0    0.0     0.0     0.0
 CAF            Main                       352  33    0.0    0.0     0.0     0.0
  addnl         Main                       364   0    0.0    0.0     0.0     0.0
  wc            Main                       359   1    0.0    0.0     0.0     0.0
 CAF            Data.Typeable              350   5    0.0    0.0     0.0     0.0
 CAF            GHC.Show                   348   1    0.0    0.0     0.0     0.0
 CAF            Data.HashTable             290   3    0.0    0.0     0.0     0.0
 CAF            GHC.IO.Handle.FD           288   3    0.0    0.0     0.0     0.0
 CAF            GHC.IO.FD                  272   4    0.0    0.0     0.0     0.0
 CAF            GHC.IO.Handle.Internals    252   1    0.0    0.0     0.0     0.0
 CAF            GHC.IO.Encoding.Iconv      246   2    0.0    0.0     0.0     0.0
 CAF            GHC.Conc.Signal            243   1    0.0    0.0     0.0     0.0
 CAF            Data.Data                  227   3    0.0    0.0     0.0     0.0
 CAF            System.....Implicit.Global 226   3    0.0    0.0     0.0     0.0
 CAF            System.....Implicit.Reader 223   1    0.0    0.0     0.0     0.0
 CAF            Data.Generics.Any.Prelude  222   2    0.0    0.0     0.0     0.0
 CAF            System.....Explicit        209   6    0.0    0.0     0.0     0.0
 CAF            System.....Explicit.Type   202   1    0.0    0.0     0.0     0.0
 CAF            System.....Explicit.Help   189   1    0.0    0.0     0.0     0.0
 CAF            System.....Implicit.Ann    187   4    0.0    0.0     0.0     0.0
 CAF            System.....Annotate        186   1    0.0    0.0     0.0     0.0
 CAF            Data.ByteString.Char8      184   1    0.0    0.0     0.0     0.0
</console>
<p>With the above we can now see that we&#8217;re spending 50% of our time in countlines and the other 50% in the main functio which is most likely in the <strong>interact</strong> function reading the input and 50% of the time parsing and counting in the <strong>countlines</strong>. Since we don&#8217;t have access to the <strong>interact</strong> function what we can do is create <strong>cost centres</strong> for the <strong>countlines</strong> function and see if it identifies something we weren&#8217;t expect. So we&#8217;ll add this to our source:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>countwords</span> <span class='ow'>=</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>pack</span> <span class='o'>.</span> <span class='n'>show</span> <span class='o'>.</span> <span class='n'>length</span> <span class='o'>.</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>words</span>
<span class='nf'>countlines</span> <span class='ow'>=</span> <span class='cm'>{-# SCC &quot;C.pack&quot; #-}</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>pack</span> <span class='o'>.</span> <span class='cm'>{-# SCC &quot;show&quot; #-}</span> <span class='n'>show</span> <span class='o'>.</span> <span class='nf'>\</span>
             <span class='cm'>{-# SCC &quot;length&quot; #-}</span> <span class='n'>length</span> <span class='o'>.</span> <span class='cm'>{-# SCC &quot;C.lines&quot; #-}</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>lines</span>
<span class='nf'>countchars</span> <span class='ow'>=</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>pack</span> <span class='o'>.</span> <span class='n'>show</span> <span class='o'>.</span> <span class='kt'>C</span><span class='o'>.</span><span class='n'>length</span>
</code></pre>
</div>
<p>So when we recompile and run with the above <strong>cost centres</strong> we can then get more detail from profiling:</p>
<console>
COST CENTRE  MODULE        no.    entries  %time %alloc   %time %alloc$
$
MAIN         MAIN            1           0  75.0    0.5   100.0  100.0$
 C.pack      Main          358           1   0.0    0.0    25.0   99.4$
  show       Main          359           1   0.0    0.0    25.0   99.4$
   length    Main          360           1   0.0    0.0    25.0   99.4$
    C.lines  Main          361           1  25.0   99.4    25.0   99.4$
</console>
<p>We can see that we&#8217;re spending about 25% of our time each of the places we set those <strong>cost centres</strong>. The thing to do now is try to understand why it takes 25% of the time to do the pack call or the show call when they&#8217;re just converting an <strong>Int</strong> to <strong>String</strong> and then to a <strong>ByteString</strong>. I just wanted to show how to profile an existing tool and that <strong>Haskell</strong> can in fact be as quick as <strong>C</strong> without having to any major changes and using the right types.</p>

<p>So we&#8217;ve pretty much optimized our <strong>wc</strong> implementation and the only thing left to do is a detailed comparison of the performance of our implementation vs the C implementation:</p>

<p>Counting lines in a file with 500,000 lines where all lines have 80 columns:</p>

<ul>
<li>Ref Implementation: 0.084s</li>

<li>Our Implementation: 0.149s</li>
</ul>

<p>Counting words in a file with 500,000 lines where all lines have 80 columns:</p>

<ul>
<li>Ref Implementation: 1.243s</li>

<li>Our Implementation: 0.742s</li>
</ul>

<p>Counting chars in a file with 500,000 lines where all lines have 80 columns:</p>

<ul>
<li>Ref Implementation: 1.224s</li>

<li>Our Implementation: 0.116s</li>
</ul></div>
             </article>
             <hr/>
             <div id="disqus_thread"></div>
             <script type="text/javascript">
                    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                    var disqus_shortname = 'rodneyscorner'; // required: replace example with your forum shortname

                    /* * * DON'T EDIT BELOW THIS LINE * * */
                    (function() {
                        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                    })();
              </script>
              <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
          <div class="span4">
            
                <h2>Related Posts</h2>
                <ul>
                    
                    <li><a href="/work/haskell/2011/11/13/13.00-Writing-wc-command-line-tool-in-Haskell.html">Writing wc command line tool in Haskell</a></li>
                    
                    <li><a href="/work/haskell/2011/11/08/22.30-Advanced-Typeclasses.html">Advanced Typeclasses</a></li>
                    
                    <li><a href="/work/haskell/2011/11/01/23.00-Higher-order-functions-in-Haskell.html">Higher order functions in Haskell</a></li>
                    
                    <li><a href="/work/haskell/2011/10/31/20.00-Custom-data-types-in-Haskell.html">Custom data types in Haskell</a></li>
                    
                    <li><a href="/work/haskell/2011/10/30/20.00-haskell-basics.html">Haskell Basics</a></li>
                    
                </ul>
            
          </div>
        </div>
      </div>
      <footer>
        <div style="text-align: right">Powered by <a href="http://jekyllrb.com/">Jekyll</a> &amp; <a href="http://twitter.github.com/bootstrap/index.html">Bootstrap</a></div>
        <div style="text-align: right">Last Updated: Wed May 16 16:16:15 -0700 2012</div>
      </footer>
    </div> <!-- /container -->
</html>
