<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Haskell Basics</title>
        <meta name="description" content="Rodney's Blog">
        <meta name="author" content="Rodney Gomes">

        <link rel="alternate"
              type="application/rss+xml"
              title="Rodney's Corner RSS Feed"
              href="http://feeds.feedburner.com/rlgomesgithubcom/feed"/>

        <link href="/css/bootstrap.css" rel="stylesheet">
        <link href="/css/main.css" rel="stylesheet"/>
    </head>
    <body>

    <div class="topbar">
      <div class="fill">
        <div class="container">
          <a class="brand" href="/">Rodney's Corner</a>
          <ul class="nav">
            <li class="active"><a href="/">Blog</a></li>
            <li><a href="/archive.html">Archive</a></li>
            <li><a href="/about.html">About</a></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="content">
        <div class="page-header">
          <h1>Haskell Basics</h1>
        </div>
        <div class="row">
          <div class="span10">
             <article>
                   <div id="post.body"><p>I will start my learning of Haskell by first going over how to write a simple program in Haskell and have it execute within the Haskell interpreter. Lets start with writing a simple &#8220;Hello World&#8221; application in Haskell:</p>
<div class='highlight'><pre><code class='hs'><span class='o'>#!</span> <span class='o'>/</span><span class='n'>usr</span><span class='o'>/</span><span class='n'>bin</span><span class='o'>/</span><span class='n'>env</span> <span class='n'>runhaskell</span>
<span class='kr'>module</span> <span class='nn'>Main</span><span class='p'>(</span><span class='n'>main</span><span class='p'>)</span> <span class='kr'>where</span>
<span class='nf'>main</span> <span class='ow'>=</span> <span class='n'>putStrLn</span> <span class='s'>&quot;Hello, World!&quot;</span>
</code></pre>
</div>
<p>That is a pretty small program even when you compare to writing hello world in an imperative language such as C. I added the shebang to make sure you&#8217;d be able to easily run this on a unix system. To run this you&#8217;ll need to install GHC compiler and intpreter which are supported on all major OS&#8217;s. For more information on getting GHC on your system have a look at: http://www.haskell.org/ghc/ .</p>

<p>Lets get into what makes a piece of code in Haskell. So unlike most mainstream languages that are imperative or object-oriented, functionl programming languages do not have the notion of a sequence of commands/instructions to execute. A functional programming language consists of a collection of functions that do a single task and return a result without any side-effects. I&#8217;m bringing up the topic of side-effects so we can understand early on that you can&#8217;t do any of the following in a function (by default):</p>

<ul>
<li>throw an exception, raise an error</li>

<li>read/write to any file (including stdin/stdout)</li>

<li>change global state (global variables)</li>
</ul>

<p>Side-effects are not &#8220;easily&#8221; represented as a pure function in a functional programming language.</p>

<p>Lets write our first function that takes a number and gives this number plus one:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>plus1</span> <span class='n'>a</span> <span class='ow'>=</span> <span class='n'>a</span> <span class='o'>+</span> <span class='mi'>1</span>
</code></pre>
</div>
<p>When writing your functions make sure to always write the signature of the function. Writing the signature helps you understand what you&#8217;re trying to write as well verifies that you haven&#8217;t created any scenario in which your function returns an unexpected result:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>plus1</span> <span class='ow'>::</span> <span class='kt'>Int</span> <span class='ow'>-&gt;</span> <span class='kt'>Int</span>
<span class='nf'>plus1</span> <span class='n'>a</span> <span class='ow'>=</span> <span class='n'>a</span> <span class='o'>+</span> <span class='mi'>1</span>
</code></pre>
</div>
<p>As you look at this function you&#8217;ll find the notation is very similar to when you were writing mathematical expressions in school. Of couse now that we have this function lets load it into the ghci shell and try to apply it to a few different values:</p>
<console>
> ghci
GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude> :l test.hs
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, modules loaded: Main.
*Main> plus1 0
1
*Main> plus1 2
3
*Main> plus1 (plus1 2)
4
*Main>
</console>
<p>Lets jump into deal with lists of data and how to write a few useful functions to deal with lists. The first thing to realize is that a list in Haskell is very simply represented as:</p>
<pre>
[1,2,3,4]
</pre>
<p>A string is a list of Char and therefore has the type [Char] and can be represented as:</p>
<pre>
['a','b','c']
</pre>
<p>which is in fact the string &#8220;abc&#8221;. Lists can also be expressed using the operator (:) which takes an element and adds it to the another list so the above list can also be presented as:</p>
<pre>
1:(2:(3:(4:[])))
</pre>
<p>With this operator we can also introduce pattern matching and how to write functions that can handle lists. Lets start by writing our very own length function that can calculate the length of a list. The first thing to write is the type of this function:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>len</span> <span class='ow'>::</span> <span class='p'>[</span><span class='kt'>Int</span><span class='p'>]</span> <span class='ow'>-&gt;</span> <span class='kt'>Int</span>
</code></pre>
</div>
<p>The above signature is aready length takes a list of Ints and returns an Int. We can easily take this a step further and make this function polymorphic which allows it to be applied to a list of any type. The signature would look like so:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>len</span> <span class='ow'>::</span> <span class='p'>[</span><span class='n'>a</span><span class='p'>]</span> <span class='ow'>-&gt;</span> <span class='kt'>Int</span>
</code></pre>
</div>
<p>The type a now represents any type that can be put in a list and with this we can write our length function, like this:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>len</span> <span class='ow'>::</span> <span class='p'>[</span><span class='n'>a</span><span class='p'>]</span> <span class='ow'>-&gt;</span> <span class='kt'>Int</span>
<span class='nf'>len</span> <span class='kt'>[]</span> <span class='ow'>=</span> <span class='mi'>0</span>
<span class='nf'>len</span> <span class='p'>(</span><span class='n'>x</span><span class='kt'>:</span><span class='n'>xs</span><span class='p'>)</span> <span class='ow'>=</span> <span class='n'>len</span> <span class='n'>xs</span> <span class='o'>+</span> <span class='mi'>1</span>
</code></pre>
</div>
<p>This definition reads very simply: the length of an empty list is 0 and the length of a list with an element x and a tail xs is equal to the length of the tail plus one. We&#8217;ve introduced here how to do pattern matching on lists and also how polymorphism works when you want to create methods that can be used against various datatypes that share a common structure. The len function shown can be used against a list of integers as well as a string which is a list of Chars. Here&#8217;s an example:</p>
<console>
...
Prelude> :l test.hs
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, modules loaded: Main.
*Main> len [3,2,1,3,4,5,5]
7
*Main> len "Hello, World!"
13
</console>
<p>Polymorphism is one of the other things I find that Haskell does really well when compared to other languages. All other languages refer to polymorphism as templates and generics and are in no way as elegant or simple to understand as polymorphism is in Haskell.</p>

<p>Most of the operations on lists you&#8217;ll ever need are already implemented in the Prelude library. Just search for &#8220;haskell prelude&#8221; and you&#8217;ll find all of the available functions, but here are a few of the everyday useful ones:</p>

<ul>
<li><strong>head</strong> - returns the head of a list</li>

<li><strong>last</strong> - returns the last element of a list</li>

<li><strong>tail</strong> - returns the same list without the first element</li>

<li><strong>init</strong> - returns the same list without the last element</li>
</ul>

<p>With these functions we can now start to talk about function composition. Which from algebra class when you had function <em>f</em> and function <em>g</em> and wanted to apply it to a single argument you&#8217;d write something like so:</p>
<pre>
(f o g) x
</pre>
<p>In haskell there is the composition function which can take two functions as its arguments and compose them together. This is how the definition of such a function might look:</p>
<div class='highlight'><pre><code class='hs'><span class='p'>(</span><span class='o'>.</span><span class='p'>)</span> <span class='ow'>::</span> <span class='p'>(</span><span class='n'>b</span> <span class='ow'>-&gt;</span> <span class='n'>c</span><span class='p'>)</span> <span class='ow'>-&gt;</span> <span class='p'>(</span><span class='n'>a</span> <span class='ow'>-&gt;</span> <span class='n'>b</span><span class='p'>)</span> <span class='ow'>-&gt;</span> <span class='p'>(</span><span class='n'>a</span> <span class='ow'>-&gt;</span> <span class='n'>c</span><span class='p'>)</span>
<span class='nf'>f</span> <span class='o'>.</span> <span class='n'>g</span> <span class='ow'>=</span> <span class='nf'>\</span><span class='n'>x</span> <span class='ow'>-&gt;</span> <span class='n'>f</span><span class='p'>(</span><span class='n'>g</span><span class='p'>(</span><span class='n'>x</span><span class='p'>))</span>
</code></pre>
</div>
<p>We&#8217;ve suddenly introduced 2 other concepts with this defintion:</p>

<ul>
<li>
<p><strong>infix functions</strong> - By default functions are defined in a prefix manner which means the function name appears before the arguments. When you want to declare functions that will appears in the middle of their arguments such as the +,/,- operators then you need to declare them as you see above wrapped with brackets and then you can define them with the function name in the middle of the arguments. You can also turn any regular prefix function into an infix function by just putting single quotes around it like so: <em><code>div</code></em> is now an infix version of the prefix <em>div</em> function.</p>
</li>

<li>
<p><strong>lambda expression</strong> - A lambda expression allows you to define an in place function in a more mathematical friendly format. You basically describe for each x what the function will do. So for example:<pre>
\x -> x + 2
</pre> declares a function that for each x passed as an argument, the function will returns x plus 2. Lambda expressions are great for saving space and not having to declare additional named functions when you just need a function to get the job done there and then.</p>
</li>
</ul>

<p>I&#8217;ll end this post with a few examples of how function composition works and how it can be useful to write functions composed of other well known functions. To start lets take a few of the useful prelude list functions we shown above and try to write a few other useful list functions by using composition:</p>

<ul>
<li>lets write a function that can give you the penultimate element of a list. We can simply call it <strong>penult</strong></li>

<li>lets write a function that can give you the same list without the first and last element and we&#8217;ll call it <strong>middle</strong></li>
</ul>

<p>So for the <strong>penult</strong> function we can compose the functions <strong>init</strong> and <strong>last</strong>, the first will give us the list without the last element and the <strong>last</strong> call will give us the last element of that list which is the penultimate element, like so:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>penult</span> <span class='ow'>::</span> <span class='p'>[</span><span class='n'>a</span><span class='p'>]</span> <span class='ow'>-&gt;</span> <span class='n'>a</span>
<span class='nf'>penult</span> <span class='ow'>=</span> <span class='n'>last</span> <span class='o'>.</span> <span class='n'>init</span>
</code></pre>
</div>
<p>and the <strong>middle</strong> function is the composition of the <strong>init</strong> and <strong>tail</strong> functions, like this:</p>
<div class='highlight'><pre><code class='hs'><span class='nf'>midddle</span> <span class='ow'>::</span> <span class='p'>[</span><span class='n'>a</span><span class='p'>]</span> <span class='ow'>-&gt;</span> <span class='p'>[</span><span class='n'>a</span><span class='p'>]</span>
<span class='nf'>middle</span> <span class='ow'>=</span> <span class='n'>tail</span> <span class='o'>.</span> <span class='n'>init</span>
</code></pre>
</div>
<p>By now you can see that the Haskell language is extremely powerful and allows you to take existing functions and put them together in a very simple way that alows you to create new and useful functions quickly and cleanly.</p>

<p>In my next post I&#8217;ll start to dive into custom data types and how to pattern match those when writing your own functions and hopefully get into representing Trees, Graphs and other datatypes and how writing functions for those in a functional language is extremely clean and simple.</p></div>
             </article>
             <hr/>
             <div id="disqus_thread"></div>
             <script type="text/javascript">
                    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                    var disqus_shortname = 'rodneyscorner'; // required: replace example with your forum shortname

                    /* * * DON'T EDIT BELOW THIS LINE * * */
                    (function() {
                        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                    })();
              </script>
              <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
          <div class="span4">
            
                <h2>Related Posts</h2>
                <ul>
                    
                    <li><a href="/work/haskell/2011/11/14/20.30-Optimizing-Haskell-Programs.html">Optimizing Haskell Programs</a></li>
                    
                    <li><a href="/work/haskell/2011/11/13/13.00-Writing-wc-command-line-tool-in-Haskell.html">Writing wc command line tool in Haskell</a></li>
                    
                    <li><a href="/work/haskell/2011/11/08/22.30-Advanced-Typeclasses.html">Advanced Typeclasses</a></li>
                    
                    <li><a href="/work/haskell/2011/11/01/23.00-Higher-order-functions-in-Haskell.html">Higher order functions in Haskell</a></li>
                    
                    <li><a href="/work/haskell/2011/10/31/20.00-Custom-data-types-in-Haskell.html">Custom data types in Haskell</a></li>
                    
                </ul>
            
          </div>
        </div>
      </div>
      <footer>
        <div style="text-align: right">Powered by <a href="http://jekyllrb.com/">Jekyll</a> &amp; <a href="http://twitter.github.com/bootstrap/index.html">Bootstrap</a></div>
        <div style="text-align: right">Last Updated: Wed May 16 16:16:15 -0700 2012</div>
      </footer>
    </div> <!-- /container -->
</html>
